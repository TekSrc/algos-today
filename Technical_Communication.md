1. Two Number Sum

- The first option is to use a loop inside a nested loop, because the outter loop would carry the first number, the inner loop going through each other number and comparing it to that first number and if added equalling the target number sum, we know. Though this requires less space, it definitely requires more time. Therefore a hashmap is a better solution. We store a hash table of the nums initialized as empty, then utilize are target num sum int subtracting the current number, if the difference does not exist in the hash table, we store it in the table with a bool of true, if we reach a number that does equate after existence, then we simple return the array with those two numbers in it. This is more space storage because of the hashmap, but it's faster at O(n) and therefore I consider it a better solution, though i would naturally lean towards the first.
- Scan the whole array once and sore vvisited elements in a hash set, during the scan, for every element in the array, I check if val - e is present in the hash set i.e. val - e is already visited. If val - e is found in the hash set, it means there is a pair (e, val -e) in array whose sum is equal to the given val. If I have exhausted all elements in the array and didn't find any such pair, the function will return false.

2. Validate Subsequence

- A concept used in harder challenges. Subsequence is a concept from mathematic in which a sequence can be derived from another sequence. Even in deleting elements order of elements in subsequence is not lost even if no change from main sequence at all. Starting with the two arrays of integers, I had to write a function to determine if the second array is a valid subsequence of the first main array. In order for array to be valid all integers in the subsequence array not only have to appear in original array, but in the same order, even if not adjacent (might be numbers inbetween). I have to traverse both arrays, subsequence to see if it appears in the first array and then also have to traverse entire main array because our sequence could be located anywhere in the main array, first to last element, could stop early if I find it before end of the array. Two pointers essentially. Because the order in the subsequence and sequence matter when I start looking for the first element, traverse main array until I find the first element from the second array. Once found, now I need to look for the second element of the second array in the main array, moving forward in traversal of both, comparing between pointers in each array. Moving along through main array. Once past traversal bound length of subsequence I can stop the algorithm despite how long main array is because it's completed. However time complexity is O(N) because though traversal through entire main array length may end early it's only in certain cases as sometimes subsequence is going to take up the entire array. Space complexity is constant, O(1) not storing any big variables or big data, only storing the pointers.

3. Sorted Squared Array

- One array of integers always sorted in ascending order and I am just called to new array of squared values in same ascending order. I am not going to modify the existing input array, thus creating new array. This can be complex because values may not always be positive values. When a negative value is added it can make it more complex. First approach is simple brute force into output array then just sort of that new array O(nlogn)/O(n) despite extra n step in time. Second solution is going to be better time complexity, should be able to solve the problem in linear time or more optimimal than the brute force approach. Can look at absolute value of the squared and see which one is larger. Look at values at beginning and end of array and if largest can move to the end, then move to the next value. 2 Pointers, one as start at the smallest and the second at the end which is largest value. Compare their absolute values and whichever is largest add to the end. move pointer backwards in new array always comparing the absolute value of the start to the idx it's on. Moving the first starter pointer forward whenever it becomes larger and goes into the new array. Eventually the pointers are on the same position which means I'm at the last element square it and put it as first position and return this.

4. Tournament Winner

-
